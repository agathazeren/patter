* Memory and Mutability Idea
** Key Idea
There are both /values/ and /objects/ (this latter one needs a better, less overloaded name.). An /object/ is a /value/ behind a /reference/. (A reference, though correlated with machine pointers, is not necessarily a pointer.) /objects/ are mutable, and have a defined lifetime. /values/ are immutable, and have no lifetime. (Or an infinite one). An /object/'s lifetime always expires at the end of the scope it was created in. (And /objects/ cannot be injected into higher scopes. Note that this does not have any restriction for returning heap allocated values, as a /value/ may be heap allocated, and dereferencing the reference could be a no op on the machine. 
** Referencing and Dereferencing
A /value/ can be turned into a reference (and a new /object/ created) by the use of the ~>~ sigil, and a reference can be turned into the /value/ of the /object/ it points to using the ~<~ sigil. 
** Mutating /Objects/
Notably, an object is *not* mutated by using the ~<~ sigil on a reference pointing to it. This would create a immutable /value/ version of the /object/, not return the /object/ itself. All mutations (because all /objects/) must be behind a reference. There are two standard library functions (implemented via intrinsics) to allow mutation. ~set~ takes two parameters, a reference, and a new value to set the /object/ pointed to by the reference to. ~update~, instead of taking a new value, takes a function that takes one parameter and is used to update the value. 
** Ordering and Atomicity. 
The ~>~, ~<~, ~set~, and ~update~ operations are all atomic. That is, they are never in an incomplete state. (Also, note that an implementation of ~update~ may run this function an undefined number of times, so it should not have side effects.) ~set~ and ~<~ have sequentially consistent release ordering, and ~>~ has acquire ordering. ~update~ is sequentially consistent with other fences other than ~update~ fences, but ~update~ may be reordered with other ~updates~. Note that the compiler can in most cases prove that the references are not shared among threads, and thus is not required to emit hardware synchronization primitives. 

